<div class="fr-select-group {% if form_input.errors %}fr-select-group--error{% endif %}" id="{{ form_input.id_for_label }}_group">
    {% if form_input.label %}
        <label class="fr-label select-label" for="{{ form_input.id_for_label }}_combobox" id="{{ form_input.id_for_label }}_label">
            {{ form_input.label }}
            {% include "common/form/required_field.html" with form_input=form_input %}
            {% include "common/help_field.html" with form_input=form_input %}
        </label>
    {% endif %}

    <div class="fr-mt-1w accessible-combobox-wrapper" id="{{ form_input.id_for_label }}_wrapper">
        <select style="display: none;" id="{{ form_input.id_for_label }}" name="{{ form_input.html_name }}" {% if form_input.required %}required{% endif %}>
            {% if not without_empty_option %}
                <option value="" {% if not form_input.value %}selected{% endif %}></option>
            {% endif %}
            {% if enum %}
                {% for element in enum %}
                    <option value="{{ element.value }}" {% if element.value == form_input.value %}selected{% endif %}>
                        {{ element.label }}
                    </option>
                {% endfor %}
            {% else %}
                {% for value, label in form_input.field.choices %}
                    <option value="{{ value|safe }}" {% if value|safe == form_input.value|safe %}selected{% endif %}>
                        {{ label }}
                    </option>
                {% endfor %}
            {% endif %}
        </select>

        <div class="combobox-container">
            <div class="combobox-input-wrapper">
                <input type="text"
                       role="combobox"
                       id="{{ form_input.id_for_label }}_combobox"
                       class="fr-select combobox-input"
                       aria-autocomplete="list"
                       aria-expanded="false"
                       aria-controls="{{ form_input.id_for_label }}_listbox"
                       aria-labelledby="{{ form_input.id_for_label }}_label"
                       autocomplete="off"
                       placeholder="{{ placeholder|default:'Rechercher...' }}">

                <button type="button" class="combobox-clear" style="display: none;">
                    <span class="fr-sr-only">Effacer la sélection</span>
                    <span aria-hidden="true">×</span>
                </button>

                <button type="button"
                        class="combobox-toggle"
                        aria-label="Afficher les options"
                        aria-expanded="false"
                        aria-controls="{{ form_input.id_for_label }}_listbox"
                        tabindex="-1">
                    <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M4 6l4 4 4-4z"/>
                    </svg>
                </button>
            </div>

            <div role="listbox"
                id="{{ form_input.id_for_label }}_listbox"
                class="combobox-listbox"
                aria-labelledby="{{ form_input.id_for_label }}_label"
                style="display: none;">
            </div>

            <div role="status" aria-live="polite" aria-atomic="true" class="fr-sr-only combobox-status"></div>
        </div>
    </div>

    {% if form_input.errors %}
        {% for error in form_input.errors %}
            <p id="select-error-desc-error" class="fr-error-text">
                {{ error }}
            </p>
        {% endfor %}
    {% endif %}
</div>

<script type="text/javascript" nonce="{{ request.csp_nonce }}">
(function() {
    'use strict';

    const fieldId = '{{ form_input.id_for_label }}';
    const combobox = document.getElementById(fieldId + '_combobox');
    const listbox = document.getElementById(fieldId + '_listbox');
    const hiddenSelect = document.getElementById(fieldId);
    const clearButton = combobox.parentElement.querySelector('.combobox-clear');
    const toggleButton = combobox.parentElement.querySelector('.combobox-toggle');
    const statusEl = combobox.closest('.combobox-container').querySelector('.combobox-status');

    let searchTimeout = null;
    let focusedOptionIndex = -1;
    let options = [];
    let allOptions = [];
    let selectedValue = '';
    let selectedText = '';

    function init() {
        const selectedOption = hiddenSelect.querySelector('option[selected]');
        if (selectedOption && selectedOption.value) {
            selectedValue = selectedOption.value;
            selectedText = selectedOption.textContent.trim();
            combobox.value = selectedText;
            updateClearButtonVisibility();
        }

        loadAllOptions();
        loadInitialOptions();

        combobox.addEventListener('input', handleInput);
        combobox.addEventListener('keydown', handleKeyDown);
        combobox.addEventListener('blur', handleBlur);
        combobox.addEventListener('click', handleComboboxClick);
        clearButton.addEventListener('click', handleClear);
        toggleButton.addEventListener('click', handleToggle);
        listbox.addEventListener('mousedown', handleListboxMouseDown);
        listbox.addEventListener('click', handleListboxClick);
    }

    function loadAllOptions() {
        const selectOptions = hiddenSelect.querySelectorAll('option');
        allOptions = [];
        for (const opt of selectOptions) {
            if (opt.value) {
                allOptions.push({
                    value: opt.value,
                    label: opt.textContent.trim(),
                    selected: opt.selected
                });
            }
        }
    }

    function loadInitialOptions() {
        renderOptions(allOptions);
    }

    function renderOptions(optionsData) {
        listbox.innerHTML = '';

        if (optionsData.length === 0) {
            const noResultLi = document.createElement('li');
            noResultLi.role = 'option';
            noResultLi.className = 'combobox-option combobox-no-results';
            noResultLi.textContent = '{{ no_results_text|default:"Aucun résultat" }}';
            listbox.appendChild(noResultLi);
        } else {
            let index = 0;
            for (const item of optionsData) {
                const li = document.createElement('li');
                li.role = 'option';
                li.id = fieldId + '_option_' + index;
                li.className = 'combobox-option';
                li.dataset.value = item.value;
                li.textContent = item.label;
                if (item.selected || item.value === selectedValue) {
                    li.setAttribute('aria-selected', 'true');
                }
                listbox.appendChild(li);
                index++;
            }
        }

        updateOptions();
        focusedOptionIndex = -1;
    }

    function updateOptions() {
        options = Array.from(listbox.querySelectorAll('[role="option"]:not(.combobox-no-results)'));
    }

    function handleInput(e) {
        const searchValue = e.target.value;

        if (searchValue !== selectedText) {
            selectedValue = '';
            updateHiddenSelect('');
            clearSelectedOption();
        }

        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            performClientSearch(searchValue);
        }, 150);
    }

    function performClientSearch(searchValue) {
        if (!searchValue) {
            renderOptions(allOptions);
            announceToScreenReader(allOptions.length + ' option' + (allOptions.length > 1 ? 's' : '') + ' disponible' + (allOptions.length > 1 ? 's' : ''));
            return;
        }

        const normalizedSearch = searchValue.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        const filtered = allOptions.filter(opt => {
            const normalizedLabel = opt.label.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            return normalizedLabel.includes(normalizedSearch);
        });

        renderOptions(filtered);

        if (filtered.length > 0) {
            openListbox();
            announceToScreenReader(filtered.length + ' résultat' + (filtered.length > 1 ? 's' : '') + ' trouvé' + (filtered.length > 1 ? 's' : ''));
        } else {
            openListbox();
            announceToScreenReader('Aucun résultat trouvé');
        }
    }

    function updateHiddenSelect(value) {
        hiddenSelect.value = value;
        const existingOption = hiddenSelect.querySelector(`option[value="${value}"]`);
        if (existingOption) {
            existingOption.selected = true;
        }
    }

    function handleKeyDown(e) {
        const isOpen = combobox.getAttribute('aria-expanded') === 'true';

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (isOpen) {
                moveFocusDown();
            } else {
                openListbox();
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (isOpen) {
                moveFocusUp();
            }
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (isOpen && focusedOptionIndex >= 0) {
                selectOption(options[focusedOptionIndex]);
            }
        } else if (e.key === 'Escape') {
            e.preventDefault();
            if (isOpen) {
                closeListbox();
                combobox.focus();
            }
        } else if (e.key === 'Tab') {
            if (isOpen) {
                closeListbox();
            }
        } else if (e.key === 'Home' && isOpen) {
            e.preventDefault();
            moveFocusToFirst();
        } else if (e.key === 'End' && isOpen) {
            e.preventDefault();
            moveFocusToLast();
        }
    }

    function handleBlur() {
        setTimeout(() => {
            if (!combobox.parentElement.contains(document.activeElement)) {
                closeListbox();
            }
        }, 100);
    }

    function handleComboboxClick() {
        const isOpen = combobox.getAttribute('aria-expanded') === 'true';
        if (!isOpen) {
            openListbox();
        }
    }

    function handleClear(e) {
        e.preventDefault();
        e.stopPropagation();
        selectedValue = '';
        selectedText = '';
        updateHiddenSelect('');
        combobox.value = '';
        clearSelectedOption();
        loadInitialOptions();
        updateClearButtonVisibility();
        closeListbox();
        combobox.focus();
        announceToScreenReader('Sélection effacée');
    }

    function handleToggle(e) {
        e.preventDefault();
        e.stopPropagation();
        const isOpen = combobox.getAttribute('aria-expanded') === 'true';
        if (isOpen) {
            closeListbox();
        } else {
            openListbox();
        }
        combobox.focus();
    }

    function handleListboxMouseDown(e) {
        e.preventDefault();
    }

    function handleListboxClick(e) {
        const option = e.target.closest('[role="option"]:not(.combobox-no-results)');
        if (option) {
            selectOption(option);
        }
    }

    function moveFocusDown() {
        if (options.length === 0) return;
        if (focusedOptionIndex < options.length - 1) {
            focusedOptionIndex++;
        } else {
            focusedOptionIndex = 0;
        }
        updateFocusedOption();
    }

    function moveFocusUp() {
        if (options.length === 0) return;
        if (focusedOptionIndex > 0) {
            focusedOptionIndex--;
        } else {
            focusedOptionIndex = options.length - 1;
        }
        updateFocusedOption();
    }

    function moveFocusToFirst() {
        if (options.length === 0) return;
        focusedOptionIndex = 0;
        updateFocusedOption();
    }

    function moveFocusToLast() {
        if (options.length === 0) return;
        focusedOptionIndex = options.length - 1;
        updateFocusedOption();
    }

    function updateFocusedOption() {
        for (const opt of options) {
            opt.classList.remove('focused');
        }
        if (focusedOptionIndex >= 0 && focusedOptionIndex < options.length) {
            const focusedOption = options[focusedOptionIndex];
            focusedOption.classList.add('focused');
            combobox.setAttribute('aria-activedescendant', focusedOption.id);
            focusedOption.scrollIntoView({ block: 'nearest' });
            announceToScreenReader(focusedOption.textContent.trim());
        } else {
            combobox.removeAttribute('aria-activedescendant');
        }
    }

    function selectOption(option) {
        selectedValue = option.dataset.value;
        selectedText = option.textContent.trim();
        updateHiddenSelect(selectedValue);
        combobox.value = selectedText;
        clearSelectedOption();
        option.setAttribute('aria-selected', 'true');
        updateClearButtonVisibility();
        closeListbox();
        combobox.focus();
        announceToScreenReader(selectedText + ' sélectionné');
    }

    function clearSelectedOption() {
        for (const opt of options) {
            opt.removeAttribute('aria-selected');
        }
    }

    function openListbox() {
        combobox.setAttribute('aria-expanded', 'true');
        toggleButton.setAttribute('aria-expanded', 'true');
        toggleButton.setAttribute('aria-label', 'Masquer les options');
        listbox.style.display = 'block';
        if (focusedOptionIndex === -1) {
            const selectedOption = listbox.querySelector('[aria-selected="true"]');
            if (selectedOption) {
                focusedOptionIndex = options.indexOf(selectedOption);
                updateFocusedOption();
            }
        }
    }

    function closeListbox() {
        combobox.setAttribute('aria-expanded', 'false');
        toggleButton.setAttribute('aria-expanded', 'false');
        toggleButton.setAttribute('aria-label', 'Afficher les options');
        listbox.style.display = 'none';
        combobox.removeAttribute('aria-activedescendant');
        focusedOptionIndex = -1;
        for (const opt of options) {
            opt.classList.remove('focused');
        }
    }

    function updateClearButtonVisibility() {
        clearButton.style.display = combobox.value ? 'flex' : 'none';
    }

    function announceToScreenReader(message) {
        statusEl.textContent = message;
    }

    init();
})();
</script>

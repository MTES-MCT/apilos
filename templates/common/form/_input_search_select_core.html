<div class="fr-select-group {% if form_input.errors %}fr-select-group--error{% endif %}" id="{{ field_id }}_group">
    {% if label %}
        <label class="fr-label select-label" for="{{ field_id }}_combobox" id="{{ field_id }}_label">
            {{ label }}
            {% include "common/form/required_field.html" with form_input=form_input %}
            {% if help_text %}
                <p class="fr-mb-0">
                    <span class="fr-hint-text" {% if form_input.id_for_label %} id="{{ form_input.id_for_label }}_help" {% endif %}>
                        {{ form_input.help_text|safe|linebreaksbr }}
                    </span>
                </p>
            {% endif %}
        </label>
    {% endif %}

    <div class="fr-mt-1w accessible-combobox-wrapper" id="{{ field_id }}_wrapper">
        {# Champ caché pour la soumission du formulaire #}
        <select style="display: none;" id="{{ field_id }}" name="{{ field_name }}" {% if mandatory_input %}required{% endif %}>
            {% if not without_empty_option %}
                <option value="" {% if not initial_value and not form_input.value %}selected{% endif %}></option>
            {% endif %}
            {% if form_input %}
                {# Mode form avec recherche serveur (ModelChoiceField) #}
                {% if form_input.field.queryset and not form_input.field.choices %}
                    {% for element in form_input.field.queryset %}
                        <option value="{{ element|attribute:form_input.field.to_field_name }}" {% if element|attribute:form_input.field.to_field_name|stringformat:"s" == form_input.value|stringformat:"s" %}selected{% endif %}>
                            {{ element }}
                        </option>
                    {% endfor %}
                {% elif enum %}
                    {# Mode form avec enum (recherche client) #}
                    {% for element in enum %}
                        <option value="{{ element.value }}" {% if element.value == form_input.value %}selected{% endif %}>
                            {{ element.label }}
                        </option>
                    {% endfor %}
                {% else %}
                    {# Mode form avec choices (recherche client) #}
                    {% for value, label in form_input.field.choices %}
                        <option value="{{ value|safe }}" {% if value|safe == form_input.value|safe %}selected{% endif %}>
                            {{ label }}
                        </option>
                    {% endfor %}
                {% endif %}
            {% else %}
                {# Mode natif #}
                {% if initial_value %}
                    <option selected value="{{ initial_value }}">{{ initial_text }}</option>
                {% endif %}
                {% for item in initial_queryset %}
                    <option value="{{ item.uuid }}">{{ item }}</option>
                {% endfor %}
            {% endif %}
        </select>

        <div class="combobox-container">
            <div class="combobox-input-wrapper">
                <input type="text"
                       role="combobox"
                       id="{{ field_id }}_combobox"
                       class="fr-select combobox-input"
                       aria-autocomplete="list"
                       aria-expanded="false"
                       aria-controls="{{ field_id }}_listbox"
                       aria-labelledby="{{ field_id }}_label"
                       autocomplete="off"
                       placeholder="{{ placeholder|default:'Rechercher...' }}"
                       {% if url or search_url %}data-url="{% if url %}{{ url }}{% else %}{{ search_url }}{% endif %}"{% endif %}
                       data-field-id="{{ field_id }}">

                <button type="button" class="combobox-clear" style="display: none;">
                    <span class="fr-sr-only">Effacer la sélection</span>
                    <span aria-hidden="true">×</span>
                </button>

                <button type="button"
                        class="combobox-toggle"
                        aria-label="Afficher les options"
                        aria-expanded="false"
                        aria-controls="{{ field_id }}_listbox"
                        tabindex="-1">
                    <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M4 6l4 4 4-4z"/>
                    </svg>
                </button>
            </div>

            <div role="listbox"
                id="{{ field_id }}_listbox"
                class="combobox-listbox"
                aria-labelledby="{{ field_id }}_label"
                style="display: none;">
            </div>

            <div role="status" aria-live="polite" aria-atomic="true" class="fr-sr-only combobox-status"></div>
        </div>
    </div>

    {% if form_input.errors %}
        {% for error in form_input.errors %}
            <p id="select-error-desc-error" class="fr-error-text">
                {{ error }}
            </p>
        {% endfor %}
    {% endif %}
</div>

<script type="text/javascript" nonce="{{ request.csp_nonce }}">
(function() {
    'use strict';

    const fieldId = '{{ field_id }}';
    const combobox = document.getElementById(fieldId + '_combobox');
    const listbox = document.getElementById(fieldId + '_listbox');
    const hiddenSelect = document.getElementById(fieldId);
    const clearButton = combobox.parentElement.querySelector('.combobox-clear');
    const toggleButton = combobox.parentElement.querySelector('.combobox-toggle');
    const statusEl = combobox.closest('.combobox-container').querySelector('.combobox-status');

    const searchUrl = combobox.dataset.url;
    const isServerSearch = !!searchUrl;

    let searchTimeout = null;
    let focusedOptionIndex = -1;
    let options = [];
    let allOptions = [];
    let selectedValue = '';
    let selectedText = '';

    function init() {
        const selectedOption = hiddenSelect.querySelector('option[selected]');
        if (selectedOption && selectedOption.value) {
            selectedValue = selectedOption.value;
            selectedText = selectedOption.textContent.trim();
            combobox.value = selectedText;
            updateClearButtonVisibility();
        }

        // IMPORTANT: Charger les options AVANT d'initialiser
        if (!isServerSearch) {
            loadAllOptionsForClientSearch();
            loadInitialOptions();
        } else {
            loadInitialOptions();
        }

        combobox.addEventListener('input', handleInput);
        combobox.addEventListener('keydown', handleKeyDown);
        combobox.addEventListener('blur', handleBlur);
        combobox.addEventListener('click', handleComboboxClick);
        clearButton.addEventListener('click', handleClear);
        toggleButton.addEventListener('click', handleToggle);
        listbox.addEventListener('mousedown', handleListboxMouseDown);
        listbox.addEventListener('click', handleListboxClick);
    }

    function loadAllOptionsForClientSearch() {
        const selectOptions = hiddenSelect.querySelectorAll('option');
        allOptions = [];
        for (const opt of selectOptions) {
            if (opt.value) {
                allOptions.push({
                    value: opt.value,
                    label: opt.textContent.trim(),
                    selected: opt.selected
                });
            }
        }
    }

    function loadInitialOptions() {
        if (isServerSearch) {
            loadServerInitialOptions();
        } else {
            renderOptions(allOptions);
            // Afficher immédiatement les options si le champ est vide
            if (!combobox.value && allOptions.length > 0) {
                combobox.placeholder = '{{ placeholder|default:"Rechercher..." }}';
            }
        }
    }

    function loadServerInitialOptions() {
        const selectOptions = hiddenSelect.querySelectorAll('option');
        listbox.innerHTML = '';

        let hasOptions = false;
        let index = 0;
        for (const opt of selectOptions) {
            if (opt.value) {
                hasOptions = true;
                const li = document.createElement('li');
                li.role = 'option';
                li.id = fieldId + '_option_' + index;
                li.className = 'combobox-option';
                li.dataset.value = opt.value;
                li.textContent = opt.textContent.trim();
                if (opt.selected) {
                    li.setAttribute('aria-selected', 'true');
                }
                listbox.appendChild(li);
                index++;
            }
        }

        if (!hasOptions) {
            const noResultLi = document.createElement('li');
            noResultLi.role = 'option';
            noResultLi.className = 'combobox-option combobox-no-results';
            noResultLi.textContent = 'Commencez à taper pour rechercher';
            announceToScreenReader('Commencez à taper pour rechercher');
            listbox.appendChild(noResultLi);
        }

        updateOptions();
    }

    function renderOptions(optionsData) {
        listbox.innerHTML = '';

        if (optionsData.length === 0) {
            const noResultLi = document.createElement('li');
            noResultLi.role = 'option';
            noResultLi.className = 'combobox-option combobox-no-results';
            noResultLi.textContent = '{{ no_results_text|default:"Aucun résultat" }}';
            listbox.appendChild(noResultLi);
        } else {
            let index = 0;
            for (const item of optionsData) {
                const li = document.createElement('li');
                li.role = 'option';
                li.id = fieldId + '_option_' + index;
                li.className = 'combobox-option';
                li.dataset.value = item.value;
                li.textContent = item.label;
                if (item.selected || item.value === selectedValue) {
                    li.setAttribute('aria-selected', 'true');
                }
                listbox.appendChild(li);
                index++;
            }
        }

        updateOptions();
        focusedOptionIndex = -1;
    }

    function updateOptions() {
        options = Array.from(listbox.querySelectorAll('[role="option"]:not(.combobox-no-results)'));
    }

    function handleInput(e) {
        const searchValue = e.target.value;

        if (searchValue !== selectedText) {
            selectedValue = '';
            updateHiddenSelect('');
            clearSelectedOption();
        }

        clearTimeout(searchTimeout);

        if (isServerSearch) {
            if (searchValue.length >= 1) {
                searchTimeout = setTimeout(() => {
                    performServerSearch(searchValue);
                }, 300);
            } else if (searchValue.length === 0) {
                loadServerInitialOptions();
                updateClearButtonVisibility();
                closeListbox();
            }
        } else {
            searchTimeout = setTimeout(() => {
                performClientSearch(searchValue);
            }, 150);
        }
    }

    function performServerSearch(searchValue) {
        announceToScreenReader('Recherche en cours...');

        fetch(searchUrl + '?q=' + encodeURIComponent(searchValue))
            .then(response => response.json())
            .then(data => {
                updateListboxWithServerResults(data);
                if (data.length > 0) {
                    openListbox();
                    announceToScreenReader(data.length + ' résultat' + (data.length > 1 ? 's' : '') + ' disponible' + (data.length > 1 ? 's' : ''));
                } else {
                    openListbox();
                    announceToScreenReader('Aucun résultat trouvé');
                }
            })
            .catch(error => {
                console.error('Erreur de recherche:', error);
                announceToScreenReader('Erreur lors de la recherche');
            });
    }

    function performClientSearch(searchValue) {
        if (!searchValue) {
            renderOptions(allOptions);
            announceToScreenReader(allOptions.length + ' option' + (allOptions.length > 1 ? 's' : '') + ' disponible' + (allOptions.length > 1 ? 's' : ''));
            return;
        }

        const normalizedSearch = searchValue.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        const filtered = allOptions.filter(opt => {
            const normalizedLabel = opt.label.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            return normalizedLabel.includes(normalizedSearch);
        });

        renderOptions(filtered);

        if (filtered.length > 0) {
            openListbox();
            announceToScreenReader(filtered.length + ' résultat' + (filtered.length > 1 ? 's' : '') + ' trouvé' + (filtered.length > 1 ? 's' : ''));
        } else {
            openListbox();
            announceToScreenReader('Aucun résultat trouvé');
        }
    }

    function updateListboxWithServerResults(data) {
        listbox.innerHTML = '';

        if (data.length === 0) {
            const noResultLi = document.createElement('li');
            noResultLi.role = 'option';
            noResultLi.className = 'combobox-option combobox-no-results';
            noResultLi.textContent = 'Aucun résultat';
            listbox.appendChild(noResultLi);
        } else {
            let index = 0;
            for (const item of data) {
                const li = document.createElement('li');
                li.role = 'option';
                li.id = fieldId + '_option_' + index;
                li.className = 'combobox-option';
                li.dataset.value = item.value;
                li.textContent = item.label;
                listbox.appendChild(li);
                index++;
            }
        }

        updateOptions();
        focusedOptionIndex = -1;
    }

    function updateHiddenSelect(value) {
        hiddenSelect.value = value;

        if (isServerSearch) {
            const existingOption = hiddenSelect.querySelector(`option[value="${value}"]`);
            if (existingOption) {
                existingOption.selected = true;
            } else if (value) {
                hiddenSelect.innerHTML = '';
                const newOption = document.createElement('option');
                newOption.value = value;
                newOption.textContent = selectedText;
                newOption.selected = true;
                hiddenSelect.appendChild(newOption);
            } else {
                hiddenSelect.innerHTML = '<option selected value></option>';
            }
        } else {
            const existingOption = hiddenSelect.querySelector(`option[value="${value}"]`);
            if (existingOption) {
                existingOption.selected = true;
            }
        }
    }

    function handleKeyDown(e) {
        const isOpen = combobox.getAttribute('aria-expanded') === 'true';

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (isOpen) {
                moveFocusDown();
            } else {
                openListbox();
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (isOpen) {
                moveFocusUp();
            }
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (isOpen && focusedOptionIndex >= 0) {
                selectOption(options[focusedOptionIndex]);
            }
        } else if (e.key === 'Escape') {
            e.preventDefault();
            if (isOpen) {
                closeListbox();
                combobox.focus();
            }
        } else if (e.key === 'Tab') {
            if (isOpen) {
                closeListbox();
            }
        } else if (e.key === 'Home' && isOpen) {
            e.preventDefault();
            moveFocusToFirst();
        } else if (e.key === 'End' && isOpen) {
            e.preventDefault();
            moveFocusToLast();
        }
    }

    function handleBlur() {
        setTimeout(() => {
            if (!combobox.parentElement.contains(document.activeElement)) {
                closeListbox();
            }
        }, 100);
    }

    function handleComboboxClick() {
        const isOpen = combobox.getAttribute('aria-expanded') === 'true';
        if (isOpen) {
            return;
        }

        if (isServerSearch && combobox.value.length >= 2) {
            performServerSearch(combobox.value);
        } else {
            openListbox();
        }
    }

    function handleClear(e) {
        e.preventDefault();
        e.stopPropagation();
        selectedValue = '';
        selectedText = '';
        updateHiddenSelect('');
        combobox.value = '';
        clearSelectedOption();
        loadInitialOptions();
        updateClearButtonVisibility();
        closeListbox();
        combobox.focus();
        announceToScreenReader('Sélection effacée');
    }

    function handleToggle(e) {
        e.preventDefault();
        e.stopPropagation();
        const isOpen = combobox.getAttribute('aria-expanded') === 'true';
        if (isOpen) {
            closeListbox();
        } else if (isServerSearch && combobox.value.length >= 2) {
            performServerSearch(combobox.value);
        } else {
            openListbox();
        }
        combobox.focus();
    }

    function handleListboxMouseDown(e) {
        e.preventDefault();
    }

    function handleListboxClick(e) {
        const option = e.target.closest('[role="option"]:not(.combobox-no-results)');
        if (option) {
            selectOption(option);
        }
    }

    function moveFocusDown() {
        if (options.length === 0) return;
        if (focusedOptionIndex < options.length - 1) {
            focusedOptionIndex++;
        } else {
            focusedOptionIndex = 0;
        }
        updateFocusedOption();
    }

    function moveFocusUp() {
        if (options.length === 0) return;
        if (focusedOptionIndex > 0) {
            focusedOptionIndex--;
        } else {
            focusedOptionIndex = options.length - 1;
        }
        updateFocusedOption();
    }

    function moveFocusToFirst() {
        if (options.length === 0) return;
        focusedOptionIndex = 0;
        updateFocusedOption();
    }

    function moveFocusToLast() {
        if (options.length === 0) return;
        focusedOptionIndex = options.length - 1;
        updateFocusedOption();
    }

    function updateFocusedOption() {
        for (const opt of options) {
            opt.classList.remove('focused');
        }
        if (focusedOptionIndex >= 0 && focusedOptionIndex < options.length) {
            const focusedOption = options[focusedOptionIndex];
            focusedOption.classList.add('focused');
            combobox.setAttribute('aria-activedescendant', focusedOption.id);
            focusedOption.scrollIntoView({ block: 'nearest' });
            announceToScreenReader(focusedOption.textContent.trim());
        } else {
            combobox.removeAttribute('aria-activedescendant');
        }
    }

    function selectOption(option) {
        selectedValue = option.dataset.value;
        selectedText = option.textContent.trim();
        updateHiddenSelect(selectedValue);
        combobox.value = selectedText;
        clearSelectedOption();
        option.setAttribute('aria-selected', 'true');
        updateClearButtonVisibility();
        closeListbox();
        combobox.focus();
        announceToScreenReader(selectedText + ' sélectionné');
    }

    function clearSelectedOption() {
        for (const opt of options) {
            opt.removeAttribute('aria-selected');
        }
    }

    function openListbox() {
        combobox.setAttribute('aria-expanded', 'true');
        toggleButton.setAttribute('aria-expanded', 'true');
        toggleButton.setAttribute('aria-label', 'Masquer les options');
        listbox.style.display = 'block';
        if (focusedOptionIndex === -1) {
            const selectedOption = listbox.querySelector('[aria-selected="true"]');
            if (selectedOption) {
                focusedOptionIndex = options.indexOf(selectedOption);
                updateFocusedOption();
            }
        }
    }

    function closeListbox() {
        combobox.setAttribute('aria-expanded', 'false');
        toggleButton.setAttribute('aria-expanded', 'false');
        toggleButton.setAttribute('aria-label', 'Afficher les options');
        listbox.style.display = 'none';
        combobox.removeAttribute('aria-activedescendant');
        focusedOptionIndex = -1;
        for (const opt of options) {
            opt.classList.remove('focused');
        }
    }

    function updateClearButtonVisibility() {
        clearButton.style.display = combobox.value ? 'flex' : 'none';
    }

    function announceToScreenReader(message) {
        statusEl.textContent = message;
    }

    init();
})();
</script>
